#Module 11 post for my LIS4370 blog. Welcome!

# Below is a function intended to flag rows of a numeric matrix x that are
# outliers in every column according to the Tukey rule.
# It contains a deliberate bug:

tukey_multiple <- function(x) {
  outliers <- array(TRUE, dim = dim(x))
  for (j in 1:ncol(x)) {
    outliers[, j] <- outliers[, j] && tukey.outlier(x[, j])
  }
  outlier.vec <- vector("logical", length = nrow(x))
  for (i in 1:nrow(x)) {
    outlier.vec[i] <- all(outliers[i, ])
  }
  return(outlier.vec)
}

# Task 1 - Reproduce the Error

# In R, create a test matrix and run the function:
set.seed(123)
test_mat <- matrix(rnorm(50), nrow = 10)

# Capture the exact error message you see.

tryCatch({
  # Code that might produce an error
  tukey_multiple(test_mat)}, error = function(e) {

    # Code to execute if an error occurs
    message("An error occurred: ", e$message) # Print or capture the error message
    return(NA) # Return a default value or handle the error as needed
  })

# Task 2 - Diagnose the Bug
# traceback()
# debug(tukey_multiple)
# tukey_multiple(test_mat)

# Reflect on why using && inside the loop causes the failure.
# (Recall that && only returns a single TRUE/FALSE for the first element,
# whereas you need element‑wise comparison.)

# To analyze this function, I have replaced 'x' with the object that will be
# passed to the functions input parameter inside the functions instructions.
tukey_multiple <- function(x) {
  # Create 2 dimensional  logical array,
  # the dimensions of 'test_mat',
  # and set value of each element to 'TRUE'
  outliers <- array(TRUE, dim = dim(test_mat))

  # For j in (1 : the number of columns in 'test_mat')
  for (j in 1:ncol(test_mat))
  {
    # The array 'outliers', every row of column 'j' gets
    # the result of the scalar comparison, from the first
    # element only of outliers[,j] and the result
    # of calling the tukey.outlier() function on
    # test_mat[,j] which, if tukey.outlier() were a
    # legitimate function would return some value
    # generated by performing an operation on the
    # value stored in test_mat[, j], which is actually
    # an array of 10 elements because all rows of
    # column 'j' are specified. This would evaluate to TRUE
    # or FALSE and stop if it is FALSE
    outliers[, j] <- outliers[, j] && tukey.outlier(test_mat[, j])
  }
  # Create array 'outlier.vec' the length of rows in 'test_mat'. 10
  # with 'FALSE' as the default value from logical vector() call
  outlier.vec <- vector("logical", length = nrow(test_mat))

  # For i in (1 : the number of rows in 'test_mat')
  for (i in 1:nrow(test_mat))
  {
    # The vector 'outlier.vec' element i gets the result
    # from the all() function being called on the outliers
    # array row i, every column.
    outlier.vec[i] <- all(outliers[i, ])
  }

  # Return the 'outlier.vec'
  return(outlier.vec)
}

# Task 3 - Fix the Code

# Edit the function so that the logical operation is applied element‑wise.
# Specifically, replace the buggy line with the correct operator.

# Corrected inside the loop:
# outliers[, j] <- outliers[, j] & tukey.outlier(x[, j])

#tukey_multiple <- function(x) {
#  outliers <- array(TRUE, dim = dim(x))
#  for (j in 1:ncol(x)) {
#    outliers[, j] <- outliers[, j] & tukey.outlier(x[, j])
#  }
#  outlier.vec <- vector("logical", length = nrow(x))
#  for (i in 1:nrow(x)) {
#    outlier.vec[i] <- all(outliers[i, ])
#  }
#  return(outlier.vec)
#}

# Task 4 - Validate Your Fix

# Re‑run your corrected function on test_mat and verify it returns a
# logical vector of length 10 without error:
corrected_tukey <- function(x) {
  outliers <- array(TRUE, dim = dim(x))
  for (j in seq_len(ncol(x))) {
    outliers[, j] <- outliers[, j] & tukey.outlier(x[, j])
  }
  outlier.vec <- logical(nrow(x))
  for (i in seq_len(nrow(x))) {
    outlier.vec[i] <- all(outliers[i, ])
  }
  outlier.vec
}

tryCatch({
  # Code that might produce an error
  corrected_tukey(test_mat)}, error = function(e) {

    # Code to execute if an error occurs
    message("An error occurred: ", e$message) # Print or capture the error message
    return(NA) # Return a default value or handle the error as needed
  })

# Still producing error message - Diagnose the Bug
# traceback()
# debug(corrected_tukey)
# corrected_tukey(test_mat)

# Identify the faulty function & Fix the Code

# Edit the function so that tukey.outlier() is removed.
corrected_tukey_multiple <- function(x) {
  # Create array
  outliers <- array(TRUE, dim = dim(x))
  for (j in seq_len(ncol(x))) {
    # Compare every element of array to x
    outliers[, j] <- outliers[, j] & x[, j]
  }
  # Create vector for 'outliers' results
  outlier.vec <- logical(nrow(x))
  for (i in seq_len(nrow(x))) {
    # Store results in vector
    outlier.vec[i] <- all(outliers[i, ])
  }
  # Return results
  outlier.vec
}

# Re‑run corrected function on test_mat and verify it returns a
# logical vector of length 10 without error:
tryCatch({
  # Code that might produce an error
  corrected_tukey_multiple(test_mat)}, error = function(e) {

    # Code to execute if an error occurs
    message("An error occurred: ", e$message) # Print or capture the error message
    return(NA) # Return a default value or handle the error as needed
  })

# Task 5 - Defensive Enhancements (Optional)

# Add checks at the top of your function to:
# Ensure x is a numeric matrix.
# Provide informative errors if assumptions aren’t met (e.g., non‑numeric columns).

enhanced_tukey_multiple <- function(x) {

  # Check 1: Ensure 'x' is a matrix
  if (!is.matrix(x)) {
    stop("Input 'x' must be a matrix.")
  }

  # Check 2: Ensure 'x' is numeric
  # is.numeric(x) checks if the *mode* of the matrix is numeric,
  # which is sufficient as matrices are atomic vectors with dimension attributes
  if (!is.numeric(x)) {
    # If the check fails, we can identify which specific columns are non-numeric
    non_numeric_cols <- names(which(!apply(x, 2, is.numeric)))

    if (length(non_numeric_cols) > 0) {
      stop(paste0("All columns in 'x' must be numeric. Non-numeric columns found: ",
                  paste(non_numeric_cols, collapse = ", ")))
    } else {
      # Fallback for other non-numeric types
      # (e.g., a matrix of logicals which isn't generally numeric)
      stop("Input 'x' must be a numeric matrix.")
    }
  }

  # Create array
  outliers <- array(TRUE, dim = dim(x))
  for (j in seq_len(ncol(x))) {
    # Compare every element of array to x
    outliers[, j] <- outliers[, j] & x[, j]
  }
  # Create vector for 'outliers' results
  outlier.vec <- logical(nrow(x))
  for (i in seq_len(nrow(x))) {
    # Store results in vector
    outlier.vec[i] <- all(outliers[i, ])
  }
  # Return results
  outlier.vec
}

# Re‑run enhanced function on test_mat and verify it returns a
# logical vector of length 10 without error:
tryCatch({
  # Code that might produce an error
  enhanced_tukey_multiple(test_mat)}, error = function(e) {

    # Code to execute if an error occurs
    message("An error occurred: ", e$message) # Print or capture the error message
    return(NA) # Return a default value or handle the error as needed
  })

# matrix test
tryCatch({
  # Code that might produce an error
  enhanced_tukey_multiple(1)}, error = function(e) {

    # Code to execute if an error occurs
    message("An error occurred: ", e$message) # Print or capture the error message
    return(NA) # Return a default value or handle the error as needed
  })

# numeric test
tryCatch({
  # Code that might produce an error
  enhanced_tukey_multiple("test one for numeric")}, error = function(e) {

    # Code to execute if an error occurs
    message("An error occurred: ", e$message) # Print or capture the error message
    return(NA) # Return a default value or handle the error as needed
  })


